.data
    	N:  .word 0         # Количество элементов массива A
    	A:  .space 40       # Массив A (максимум 10 элементов, 4 байта на элемент)
    	B:  .space 40       # Массив B (максимум 10 элементов)
    	# Подсказки для пользователя.
    	enterN: .asciz "Введите количество элементов в массиве "
	enter_element: .asciz "Введите элемент массива А "
	array_B_text: .asciz "Получившийся массив B: "
    	n_error: .asciz "Неправильное количество "

.text
main:
    	la a0, enterN           # Подготовка строки для ввода N
    	li a7, 4                # Системный вызов для вывода строки
    	ecall

    	# Ввод N
    	la a0, N                # Передаем адрес переменной N в a0
    	jal input_n             # Вызов подпрограммы для ввода N	

    	# Ввод массива A
    	la a0, A		# Передаем адрес массива А в а0
    	jal input_array         # Вызов подпрограммы для ввода массива A

    	# Формирование массива B
    	la a0, A                # Передаем адрес массива A в a0
    	la a1, B                # Передаем адрес массива B в a1
    	jal form_array          # Вызов подпрограммы для формирования массива B

    	la a0, array_B_text     # Подготовка строки для вывода массива B
    	li a7, 4                # Системный вызов для вывода строки
    	ecall 

    	# Вывод массива B
    	la a0, B                # Передаем адрес массива B в a0
    	jal output_array        # Вызов подпрограммы для вывода массива B

    	# Завершение программы
    	li a7, 10               # Код завершения
    	ecall

# Подпрограмма input_n - Ввод количества элемента в массиве A
# Принимает a0 - адрес переменной N
input_n:
    	li t0, 0                # Локальная переменная для хранения значения N
input_n_loop:
    	li a7, 5                # Системный вызов для чтения целого числа
    	ecall
    	mv t0, a0               # Сохранить введённое число в t0 (введённое значение)

    	li t1, 1                # Нижняя граница (1)
    	li t2, 10               # Верхняя граница (10)
    	blt t0, t1, input_n_error # Если N < 1, выводим ошибку
    	bgt t0, t2, input_n_error # Если N > 10, выводим ошибку

    	la t1, N                # Загрузка адреса переменной N в t1
    	sw t0, 0(t1)            # Сохранить корректное значение t0 по адресу N
    	ret

input_n_error:
	la a0, n_error 		# Вывод сообщения об ошибка
	li a7, 4
	ecall 
    	li a0, 10               # Переход на новую строку
    	li a7, 11               # Системный вызов для вывода символа
    	ecall
    	j input_n_loop



# Подпрограмма input_array - Ввод массива A
# Принимает: a0 - адрес массива A
input_array:
    	mv t0, a0                # Адрес массива A
    	li t1, 0                # Индекс массива
input_loop:
    	la a0, enter_element    # Подготовка строки для ввода элемента
    	li a7, 4                # Системный вызов для вывода строки
    	ecall
    
    	li a7, 5                # Системный вызов для чтения целого числа
    	ecall
    	sw a0, 0(t0)           # Сохранить введенное значение в массив A
    	addi t0, t0, 4         # Увеличить адрес для следующего элемента
    	addi t1, t1, 1         # Увеличить индекс
    	lw t2, N                # Загрузить значение N
    	blt t1, t2, input_loop  # Продолжить ввод, если индекс меньше N
    	ret

# Подпрограмма form_array - Формирование массива B
# Принимает: a0 - адрес массива A, a1 - адрес массива B
form_array:
    	addi sp, sp, -16        # Уменьшаем стек для 2 регистров
    	sw ra, 12(sp)           # Сохраняем возвратный адрес
    	sw t0, 8(sp)            # Сохраняем t0 (по необходимости)

    	li t2, 0                # Индекс массива
form_loop:
    	lw t3, 0(a0)           # Загрузить элемент из массива A
    	li t4, 10
    	rem t5, t3, t4         # Остаток от деления на 10 (последняя цифра)
    	li t6, 4
    	beq t5, t6, halve_value # Если последняя цифра 4, уменьшить вдвое
    	j store_value

halve_value:
    	srai t3, t3, 1         # Уменьшить значение вдвое

store_value:
    	sw t3, 0(a1)           # Сохранить элемент в массив B
    	addi a0, a0, 4         # Перейти к следующему элементу массива A
    	addi a1, a1, 4         # Перейти к следующему элементу массива B
    	addi t2, t2, 1         # Увеличить индекс
    	lw t4, N                # Загрузить значение N
    	blt t2, t4, form_loop   # Продолжить цикл, пока индекс меньше N

    	lw t0, 8(sp)            # Восстанавливаем t0
    	lw ra, 12(sp)           # Восстанавливаем возвратный адрес
    	addi sp, sp, 16         # Освобождаем место на стеке
    	ret

# Подпрограмма output_array - Вывод массива B
# Принимает: a0 - адрес массива B
output_array:
    	la t0, B                # Сохраняем адрес массива B в t0
    	li t1, 0                # Индекс массива
output_loop:
    	lw a0, 0(t0)            # Загрузить элемент из массива B
    	li a7, 1                # Системный вызов для вывода целого числа
    	ecall
    	li a0, 32               # Печать пробела между числами
    	li a7, 11               # Системный вызов для вывода символа
    	ecall
    	addi t0, t0, 4         # Перейти к следующему элементу массива B
    	addi t1, t1, 1         # Увеличить индекс
    	lw t2, N                # Загрузить значение N
    	blt t1, t2, output_loop # Продолжить цикл, пока индекс меньше N
    	ret
